# 10 Innodb存储引擎

## 10.1 关键特性

- B-tree索引+聚簇索引
- 数据缓存与加密
- 外键支持
- 行级锁
- 事务和MVCC
- 复制和备份恢复

![](http://mysql317.oss-cn-beijing.aliyuncs.com/InnoDBStorageEngineFeatures.png)

## 10.2 Innodb逻辑结构图

![](http://mysql317.oss-cn-beijing.aliyuncs.com/innodb-architecture5.7.png)



## 10.3 Innodb内存结构

### 10.3.1 Buffer Pool

前面的文章Mysql索引介绍中,我们知道Innodb是以页为储存单位来保存数据的,`读取和处理数据的时候同样需要已页为单位将数据加载到内存中` 

如果没有Buffer Pool会进行频繁的磁盘IO,这样会大大拉低Mysql的性能,因此Mysql使用Buffer Pool来做存储数据和索引的缓存,容许在内存中直接操作表数据,提高处理速度

>Buffer Pool 的功能就是 缓存“页” ，减少磁盘IO,提高读写效率。

#### 10.3.1.1 Buffer Pool结构

![](http://mysql317.oss-cn-beijing.aliyuncs.com/buffer_pool1.png)

![](http://mysql317.oss-cn-beijing.aliyuncs.com/bufferpoolself.png)



Buffer Poll是由一个个Instance组成,每个instance都有自己的锁，信号量，物理块(Buffer chunks)以及逻辑链表(下面的各种List)，即`各个instance之间没有竞争关系，可以并发读取与写入`。所有instance的物理块(Buffer chunks)在数据库启动的时候被分配，直到数据库关闭内存才予以释放

```
innodb_buffer_pool_instances = innodb_buffer_pool_size/innodb_buffer_pool_instance
Instance实例数目=BufferPool总大小/每个Instance的大小
【注意】当innodb_buffer_pool_size小于1GB时候，innodb_buffer_pool_instances被重置为1，主要是防止有太多小的instance从而导致性能问题
```

每个Buffer Pool Instance有一个page hash链表，通过它，使用space_id和page_no就能快速找到已经被读入内存的数据页，而不用线性遍历LRU List去查找。

注意这个hash表不是InnoDB的自适应哈希(AHI)，自适应哈希是为了减少Btree的扫描，而page hash是为了避免扫描LRU List。

`Buffer Pool会通过三种Page和链表来管理这些经常访问的数据，保证热数据不被置换出Buffer Pool`

#### 10.3.1.2 Page的分类



![](http://mysql317.oss-cn-beijing.aliyuncs.com/pageclass.png)

#### 10.3.1.2 链表的分类

链表节点是数据页的控制体(控制体中有指针指向真正的数据页)，链表中的所有节点都有同一的属性，引入其的目的是方便管理

![](http://mysql317.oss-cn-beijing.aliyuncs.com/listclass.png)





- Free List

  Free 链表 存放的是空闲页面，初始化的时候申请一定数量的页面

  在执行SQL的过程中，每次成功load 页面到内存后，会判断Free 链表的页面是否够用。如果不够用的话，就flush LRU 链表和Flush 链表来释放空闲页。如果够用，就从Free 链表里面删除对应的页面，在LRU 链表增加页面，保持总数不变。

- LRU List

  默认情况下：

  1. Old 链表占整个LRU 链表的比例是3/8。该比例由`innodb_old_blocks_pct`控制，默认值是37（3/8*100）。该值取值范围为5~95，为全局动态变量。

  2. 当新的页被读取到Buffer Pool里面的时候，和`传统的LRU算法插入到LRU链表头部不同，Innodb LRU算法是将新的页面插入到Yong 链表的尾部和Old 链表的头部中间的位置，这个位置叫做Mid Point`，如下图所示

     ![](http://mysql317.oss-cn-beijing.aliyuncs.com/lrulist.png)

     

     

  3. 频繁访问一个Buffer Pool的页面，会促使页面往Young链表的头部移动。如果一个Page在被读到Buffer Pool后很快就被访问(需要超过innodb_old_block_time)，那么该Page会往Young List的头部移动，但是如果一个页面是通过预读的方式读到Buffer Pool，且之后短时间内没有被访问，那么很可能在下次访问之前就被移动到Old List的尾部，而被驱逐了。

  4. 随着数据库的持续运行，新的页面被不断的插入到LRU链表的Mid Point，Old 链表里的页面会逐渐的被移动Old链表的尾部。同时，当经常被访问的页面移动到LRU链表头部的时候，那些没有被访问的页面会逐渐的被移动到链表的尾部。最终，位于Old 链表尾部的页面将被驱逐。

  5. 如果一个数据页已经处于Young 链表，当它再次被访问的时候，`只有当其处于Young 链表长度的1/4(大约值)之后，才会被移动到Young 链表的头部`。这样做的目的是减少对LRU 链表的修改，因为LRU 链表的目标是保证经常被访问的数据页不会被驱逐出去。

  6. innodb_old_blocks_time 控制的Old 链表头部页面的转移策略。`该Page需要在Old 链表停留超过innodb_old_blocks_time 时间，之后再次被访问，才会移动到Young 链表`。这么操作是避免Young 链表被那些只在innodb_old_blocks_time时间间隔内频繁访问，之后就不被访问的页面塞满，从而有效的保护Young 链表。

  7. 在全表扫描或者全索引扫描的时候，Innodb会将大量的页面写入LRU 链表的Mid Point位置，并且只在短时间内访问几次之后就不再访问了。设置innodb_old_blocks_time的时间窗口可以有效的保护Young List，保证了真正的频繁访问的页面不被驱逐。`innodb_old_blocks_time 单位是毫秒，默认值是1000，即１秒。调大该值提高了从Old链表移动到Young链表的难度，会促使更多页面被移动到Old 链表，老化，从而被驱逐`

  8. 当扫描的表很大，Buffer Pool都放不下时，可以将innodb_old_blocks_pct设置为较小的值，这样只读取一次的数据页就不会占据大部分的Buffer Pool。例如，设置innodb_old_blocks_pct = 5，会将仅读取一次的数据页在Buffer Pool的占用限制为5％。当经常扫描一些小表时，这些页面在Buffer Pool移动的开销较小，我们可以适当的调大innodb_old_blocks_pct，例如设置innodb_old_blocks_pct = 50

  

  在SHOW ENGINE INNODB STATUS 里面提供了Buffer Pool一些监控指标，有几个我们需要关注一下：

  ```mysql
  =====================================
  mysql> show engine innnodb status\G
  ……
  Pages made young 0, not young 0
  0.00 youngs/s, 0.00 non-youngs/s
  ======================================
  数据页从冷到热，称为young；not young就是数据在没有成为热数据情况下就被刷走的量(累计值)。
  ```

  

  | 指标             | 场景                           | 处理方法                                                     | 作用                                                         |
  | :--------------- | :----------------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
  | youngs/s很小     | 都是一些小事务，没有大表全扫描 | 调大innodb_old_blocks_pct，减小innodb_old_blocks_time        | 使Old List 的长度更长，到Old List 的尾部消耗的时间会更久，提升下一次访问到Old List里面的页面的可能性 |
  | youngs/s很大     |                                | 可以调小innodb_old_blocks_pct，同时调大innodb_old_blocks_time | 保护热数据                                                   |
  | non-youngs/s很大 | 大量的全表扫描                 | 可以调小innodb_old_blocks_pct，同时调大innodb_old_blocks_time | 保护young list                                               |
  | non-youngs/s不大 | 存在大量全表扫描               | 调大innodb_old_blocks_time                                   | 使得这些短时间频繁访问的页面保留在Old 链表里面               |

  每隔1秒钟，Page Cleaner线程执行LRU List Flush的操作，来释放足够的Free Page。innodb_lru_scan_depth 变量控制每个Buffer Pool实例每次扫描LRU List的长度，来寻找对应的脏页，执行Flush操作。

-  Flush List

  1. Flush 链表里面保存的都是脏页，也会存在于LRU 链表。
  2. Flush 链表是按照oldest_modification排序，值大的在头部，值小的在尾部
  3. 当有页面访被修改的时候，使用mini-transaction，对应的page进入Flush 链表
  4. 如果当前页面已经是脏页，就不需要再次加入Flush list，否则是第一次修改，需要加入Flush 链表
  5. 当Page Cleaner线程执行flush操作的时候，从尾部开始scan，将一定的脏页写入磁盘，推进检查点，减少recover的时间



### 10.3.2 Change Buffer

### 10.3.3 Adaptive Hash Index(AHI)

### 10.3.4 Log Buffer