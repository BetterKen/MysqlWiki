# 6 Mysql索引介绍

【注意】主要介绍Innodb的索引结构

## 6.1 Innodb索引组织表

和MyISAM的一个大区别,在Innodb的存储引擎中,表都是根据`主键`顺序组织存放的.我们把这种存储方式的表成为`索引组织表(index origanized table)`即大家常说的`IOT`方式

Innodb规定每一个表必须需要有主键(PK),主键的选择方式按照如下顺序选择:

1. 如有有定义主键 则选择此主键
2. 如果为定义主键 选择`第一个定义的非空唯一索引`做主键:这里注意有三个条件:`非空`,`唯一`,`第一个满足以上两个条件的索引`
3. 如果以上两个都没有,Innodb会自动创建一个6字节大小的指针:隐式的创建,平时查询不能看到

```mysql
我们可以通过以下语句查看每一行的主键id,
select *,_rowid form table;

_rowid表示表的主键 
需要注意的是 _rowid只能用于查看单个列为主键的情况 对于多列组成的主键就不好使了
```

## 6.1 Innodb逻辑存储结构

之间介绍过Innodb库表的文件结构为两个:

```
${tablename}.frm   #表结构文件
${tablename}.idb   #表索引及数据文件
```
所有的数据都被逻辑的存放在一个空间中(.idb文件中),我们称这个空间为`表空间(tablespace)`

表空间的组成结构如下图所示:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/innodb_engine_struct.png)

这样看可能不明显 再看一个:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/tablespace.png)



```
可以看到:
表空间
  ↓
段segment
  ↓
区extent
  ↓
页page/块block   <---最小储存单元

而页里面包含了一个一个的行数据
  
```

### 6.2.1 表空间

在5.6以前所有的数据都存在共享表空间ibdata1中，在5.6以后加入了`innodb_file_per_table`参数默认是开启的,建议也是开启的,开启了这个参数后,每张表内的数据会单独放到一个表空间内

需要注意的是:每张表空间内存放的只有:

- 数据
- 索引
- 插入缓存Bitmap

其他的一些信息如:undo操作,插入缓存索引页,失误信息,double write buffer还是存在ibdata里

ibdata的具体介绍会在innodb索引章节进行介绍说明

### 6.2.2 段

常见的段分类如下:

- 数据段
- 索引段
- 回滚段

### 6.2.3 区 

区是由`连续的页`组成的空间,`在任何情况下每个区的大小都为1MB`

为了保证区的连续性,每次存储引擎都会从磁盘申请四五个区

默认情况下,Innodb页的大小为16KB,即一个区共有64个页  => (2^10) / (2^4)

页的大小可以在初始化的时候进行调整,但是区的大小总为1MB

### 6.2.4 页

页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB

可以通过参数`innodb_page_size`将页的大小设置为4K、8K、16K

若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改

除非通过mysqldump导入和导出操作来产生新的库

innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是`innodb_page_size` (16384(16k))的整数倍

```
[root@centos7-1 baseinfo]# ll|grep 'ibd' 
-rw-r-----. 1 mysql mysql 2663383040 xxx.ibd  => 2663383040 = 16384*162560
-rw-r-----. 1 mysql mysql  868220928 ccc.ibd  => 868220928 = 16384*52992
```



`innodb_page_size`的大小限制了tablespace表空间的大小:

Table 14.25 InnoDB Maximum Tablespace Size

| InnoDB Page Size | Maximum Tablespace Size |
| ---------------- | ----------------------- |
|4KB|16TB|
|8KB|32TB|
|16KB|64TB|
|32KB|128TB|
|64KB|256TB|

### 6.2.5 行

Innodb存储引擎是面向列的,也就是数据是按行存放的,每个页存放行的记录也是有硬性规定的

最多允许存放16KB/2-200行记录,即7992行

但实际上互联网公司一行的数据大概为1KB,即一个page可以存放16行数据

## 6.3 B+树结构

无论是MyISAM还是Innodb 他们在存储数据时,都用到了B+树结构

### 6.3.1 B+树结构

(1) 原理图:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/BTree.png)

(2)特点：

- 非叶子节点只存储键值信息
- 所有叶子节点之间都有一个链指针
- 叶子节点也多存储了指向下一个叶子节点的指针，更方便叶子节点的范围遍历
- 数据记录都存放在叶子节点中
- 所有的叶子节点组成一个循环双向链表

### 6.3.2 MyISAM实现B+Tree

(1)原理图：

![](http://mysql317.oss-cn-beijing.aliyuncs.com/MtISAMBTree.png)

(2)特点：

- 索引文件和数据文件是分离的
- 索引文件仅保存数据行记录的地址（行指针）
- 主索引与二级索引无区别
- 二级索引也存储的是行指针

### 6.3.3 Innodb实现B+Tree

(1)原理图：

![](http://mysql317.oss-cn-beijing.aliyuncs.com/InnodbBtree.png)

(2)特点：

- 主键索引既存储索引值，又在叶子节点中存储整行的数据
- 二级索引存储索引列值+主键信息
- 必须有主键 主键的选择如前文所释

## 6.4 索引分类

我们根据索引文件是否和数据文件共同存储,可讲索引分为:

- 聚簇索引(聚集索引)
- 非聚簇索引(辅助索引)

不管是聚簇索引还是非聚簇索引我们看到他们内部都是B+树的,即高度平衡的,他们之间的区别是叶子节点是否存放的是一整行数据信息



### 6.4.1 聚簇索引

Innodb的数据页同B+树数据结构一样,每个页都通过一个双向链表来进行链接。

由于实际的数据页只能按照一颗B+树进行排序,因此每张表只能拥有一个`聚簇索引`

在多数情况下,查询优化器倾向与采用聚簇索引:

- 聚簇索引能够在叶子节点上直接找到数据
- 由于定义了数据的逻辑顺序,聚簇索引能够特别快的访问针对范围值的查询

【注意】聚簇索引的存储并不是物理上连续的,而是逻辑上连续的:

- 页通过双向链表链接,页按照主键的顺序排序
- 每个页的记录也是通过双向链表进行维护的,物理储存上可以同样不按照主键存储

### 6.4.1 非聚集索引

对于非聚集索引,叶子节点不包含行记录的全部数据。叶子节点除了包含主键值以外,每个叶子节点的索引行还包含了一个书签(bookmark),在Innodb数据引擎中,这个bookmark就代表相应行数据的聚集索引键

他们之间的关系如下:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/IndexRelat.jpg)

辅助索引的存在并不影响数据在聚集索引中的组织，因此`每张表上可以有多个辅助索引，但只能有一个聚集索引`。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。

当然后面优化器部分会有相应的优化算法来优化IO次数



## 6.4 索引作用

> 索引是存储引擎用于快速找到记录的一种数据结构,这是索引的基本功能

### 6.4.1 索引的优点

- 索引大大检索了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变为顺序IO



### 6.4.2 索引平衡

索引太多,应用程序的性能可能受到影响,索引太少,对查询性能又会产生影响,要找到一个平衡点至关重要。

不要总是在事后才想起添加索引,设计表时要知道数据的使用,从一开始就应该在需要处添加索引

当然索引并不一定是最好的解决方案:

- 在创建索引，更新数据表的时候，会给数据库带来额外的消耗。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。

- 对于非常小的表，大部分情况下全表扫描更高效。

- 对于中到大型的表，索引特别有效
- 但是对于特大型的表，建立和使用索引带来的代价将随之增长，这种情况下，需要使用一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配。例如分区表技术;



## 6.5 索引种类

- 聚簇索引
  - 主键索引
- 非聚簇索引
  - 普通单列索引
  - 唯一索引
  - 前缀索引
  - 多列索引

### 6.5.1 主键索引

必须要有的索引，用于构建聚簇索引的基本条件

一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。

关键字及创建方式:

```mysql
  PRIMARY KEY (`id`)
```

### 6.5.2 普通单列索引

普通索引是最基本的索引类型，唯一的任务是加快对数据的访问速度，没有任何限制。

关键字及创建方式:

```mysql
CREATE INDEX index_name ON TABLE(column_name);
ALTER TABLE table_name ADD INDEX index_name(column_name);
INDEX index_name (name(length))
```

### 6.5.3 唯一索引

索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

关键字及创建方式:

```mysql
UNIQUE INDEX index_name (column_name)
CREATE UNIQUE INDEX index_name ON mytable(column_name)
ALTER TABLE table_name ADD UNIQUE indexName(column_name)

```

### 6.5.4 前缀索引

有时候需要索引很长的字符列，这会让索引变得大且慢。

通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。

换句话说，`前缀的”基数“应该接近于完整的列的”基数“`。

【注意】前缀索引只能作用在普通索引上 不能作用在唯一索引上

那就是计算完整列的选择性，并使其前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：

```mysql
mysql> select count(distinct city) / count(*) from city_demo;
+---------------------------------+
| count(distinct city) / count(*) |
+---------------------------------+
|                          0.4283 |
+---------------------------------+
1 row in set (0.05 sec)

```

可以在一个查询中针对不同前缀长度的选择性进行计算，这对于大表非常有用，下面给出如何在同一个查询中计算不同前缀长度的选择性：

```mysql
mysql> select count(distinct left(city,3))/count(*) as sel3,
    -> count(distinct left(city,4))/count(*) as sel4,
    -> count(distinct left(city,5))/count(*) as sel5, 
    -> count(distinct left(city,6))/count(*) as sel6 
    -> from city_demo;
+--------+--------+--------+--------+
| sel3   | sel4   | sel5   | sel6   |
+--------+--------+--------+--------+
| 0.3367 | 0.4075 | 0.4208 | 0.4267 |
+--------+--------+--------+--------+
1 row in set (0.01 sec)
```

可以看见当索引前缀为6时的基数是0.4267，已经接近完整列选择性0.4283。

在上面的示例中，已经找到了合适的前缀长度，下面创建前缀索引：

```mysql
mysql> alter table city_demo add key (city(6));
Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0
```



前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其`缺点`：

- mysql无法使用其前缀索引做ORDER BY和GROUP BY
- 无法使用前缀索引做覆盖扫描。



### 6.5.5 多列索引

指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。

关键字及创建方式:

```mysql
ALTER TABLE table ADD INDEX name_city_age (name,city,age);
```

联合索引在内部的结构图如下图所示:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/unionindex.png)

对于联合索引（a,b），where a =xxx and b =xxx，和where a=xxx 可以使用此联合索引，但是对于where b = xxx不能使用，因为b列数据在此联合索引上不是有序的。具体的索引是否生效会在以后章节介绍。



## 6.6 覆盖索引

### 6.6.1 定义

SQL只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据。

这样可以减少大量的IO操作,无需进行回表操作。

### 6.6.2 判断标准

使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为`using index`,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询

### 6.6.3 优点

覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据有以下一些优点
1、索引项通常比记录要小，所以MySQL访问更少的数据
2、索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O
3、大多数据引擎能更好的缓存索引，比如MyISAM只缓存索引
4、覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了