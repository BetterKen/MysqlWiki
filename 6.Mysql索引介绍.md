# 6 Mysql索引介绍

【注意】主要介绍Innodb的索引结构

## 6.1 Innodb索引组织表

和MyISAM的一个大区别,在Innodb的存储引擎中,表都是根据`主键`顺序组织存放的.我们把这种存储方式的表成为`索引组织表(index origanized table)`即大家常说的`IOT`方式

Innodb规定每一个表必须需要有主键(PK),主键的选择方式按照如下顺序选择:

1. 如有有定义主键 则选择此主键
2. 如果为定义主键 选择`第一个定义的非空唯一索引`做主键:这里注意有三个条件:`非空`,`唯一`,`第一个满足以上两个条件的索引`
3. 如果以上两个都没有,Innodb会自动创建一个6字节大小的指针:隐式的创建,平时查询不能看到

```mysql
我们可以通过以下语句查看每一行的主键id,
select *,_rowid form table;

_rowid表示表的主键 
需要注意的是 _rowid只能用于查看单个列为主键的情况 对于多列组成的主键就不好使了
```

## 6.1 Innodb逻辑存储结构

之间介绍过Innodb库表的文件结构为两个:

```
${tablename}.frm   #表结构文件
${tablename}.idb   #表索引及数据文件
```
所有的数据都被逻辑的存放在一个空间中(.idb文件中),我们称这个空间为`表空间(tablespace)`

表空间的组成结构如下图所示:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/innodb_engine_struct.png)

这样看可能不明显 再看一个:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/tablespace.png)



```
可以看到:
表空间
  ↓
段segment
  ↓
区extent
  ↓
页page/块block   <---最小储存单元

而页里面包含了一个一个的行数据
  
```

### 6.2.1 表空间

在5.6以前所有的数据都存在共享表空间ibdata1中，在5.6以后加入了`innodb_file_per_table`参数默认是开启的,建议也是开启的,开启了这个参数后,每张表内的数据会单独放到一个表空间内

需要注意的是:每张表空间内存放的只有:

- 数据
- 索引
- 插入缓存Bitmap

其他的一些信息如:undo操作,插入缓存索引页,失误信息,double write buffer还是存在ibdata里

ibdata的具体介绍会在innodb索引章节进行介绍说明

### 6.2.2 段

常见的段分类如下:

- 数据段
- 索引段
- 回滚段

### 6.2.3 区 

区是由`连续的页`组成的空间,`在任何情况下每个区的大小都为1MB`

为了保证区的连续性,每次存储引擎都会从磁盘申请四五个区

默认情况下,Innodb页的大小为16KB,即一个区共有64个页  => (2^10) / (2^4)

页的大小可以在初始化的时候进行调整,但是区的大小总为1MB

### 6.2.4 页

页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB

可以通过参数`innodb_page_size`将页的大小设置为4K、8K、16K

若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改

除非通过mysqldump导入和导出操作来产生新的库

innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是`innodb_page_size` (16384(16k))的整数倍

```
[root@centos7-1 baseinfo]# ll|grep 'ibd' 
-rw-r-----. 1 mysql mysql 2663383040 xxx.ibd  => 2663383040 = 16384*162560
-rw-r-----. 1 mysql mysql  868220928 ccc.ibd  => 868220928 = 16384*52992
```



`innodb_page_size`的大小限制了tablespace表空间的大小:

Table 14.25 InnoDB Maximum Tablespace Size

| InnoDB Page Size | Maximum Tablespace Size |
| ---------------- | ----------------------- |
|4KB|16TB|
|8KB|32TB|
|16KB|64TB|
|32KB|128TB|
|64KB|256TB|

### 6.2.5 行

Innodb存储引擎是面向列的,也就是数据是按行存放的,每个页存放行的记录也是有硬性规定的

最多允许存放16KB/2-200行记录,即7992行

但实际上互联网公司一行的数据大概为1KB,即一个page可以存放16行数据

## 6.3 B+树结构

无论是MyISAM还是Innodb 他们在存储数据时,都用到了B+树结构

### 6.3.1 B+树结构

(1) 原理图:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/BTree.png)

(2)特点：

- 非叶子节点只存储键值信息
- 所有叶子节点之间都有一个链指针
- 叶子节点也多存储了指向下一个叶子节点的指针，更方便叶子节点的范围遍历
- 数据记录都存放在叶子节点中
- 所有的叶子节点组成一个循环双向链表

### 6.3.2 MyISAM实现B+Tree

(1)原理图：

![](http://mysql317.oss-cn-beijing.aliyuncs.com/MtISAMBTree.png)

(2)特点：

- 索引文件和数据文件是分离的
- 索引文件仅保存数据行记录的地址（行指针）
- 主索引与二级索引无区别
- 二级索引也存储的是行指针

### 6.3.3 Innodb实现B+Tree

(1)原理图：

![](http://mysql317.oss-cn-beijing.aliyuncs.com/InnodbBtree.png)

(2)特点：

- 主键索引既存储索引值，又在叶子节点中存储整行的数据
- 二级索引存储索引列值+主键信息
- 必须有主键 主键的选择如前文所释

## 6.4 索引分类

我们根据索引文件是否和数据文件共同存储,可讲索引分为:

- 聚簇索引(聚集索引)
- 非聚簇索引(辅助索引)

不管是聚簇索引还是非聚簇索引我们看到他们内部都是B+树的,即高度平衡的,他们之间的区别是叶子节点是否存放的是一整行数据信息



### 6.4.1 聚簇索引

Innodb的数据页同B+树数据结构一样,每个页都通过一个双向链表来进行链接。

由于实际的数据页只能按照一颗B+树进行排序,因此每张表只能拥有一个`聚簇索引`

在多数情况下,查询优化器倾向与采用聚簇索引:

- 聚簇索引能够在叶子节点上直接找到数据
- 由于定义了数据的逻辑顺序,聚簇索引能够特别快的访问针对范围值的查询

【注意】聚簇索引的存储并不是物理上连续的,而是逻辑上连续的:

- 页通过双向链表链接,页按照主键的顺序排序
- 每个页的记录也是通过双向链表进行维护的,物理储存上可以同样不按照主键存储

### 6.4.1 非聚集索引

对于非聚集索引,叶子节点不包含行记录的全部数据。叶子节点除了包含主键值以外,每个叶子节点的索引行还包含了一个书签(bookmark),在Innodb数据引擎中,这个bookmark就代表相应行数据的聚集索引键

他们之间的关系如下:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/IndexRelat.jpg)

辅助索引的存在并不影响数据在聚集索引中的组织，因此`每张表上可以有多个辅助索引，但只能有一个聚集索引`。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。

当然后面优化器部分会有相应的优化算法来优化IO次数



## 6.4 索引作用

> 索引是存储引擎用于快速找到记录的一种数据结构,这是索引的基本功能

### 6.4.1 索引的优点

- 索引大大检索了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变为顺序IO



### 6.4.2 索引平衡

索引太多,应用程序的性能可能受到影响,索引太少,对查询性能又会产生影响,要找到一个平衡点至关重要。

不要总是在事后才想起添加索引,设计表时要知道数据的使用,从一开始就应该在需要处添加索引

当然索引并不一定是最好的解决方案:

- 在创建索引，更新数据表的时候，会给数据库带来额外的消耗。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。

- 对于非常小的表，大部分情况下全表扫描更高效。

- 对于中到大型的表，索引特别有效
- 但是对于特大型的表，建立和使用索引带来的代价将随之增长，这种情况下，需要使用一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配。例如分区表技术;



## 6.5 索引种类

- 聚簇索引
  - 主键索引
- 非聚簇索引
  - 普通单列索引
  - 唯一索引
  - 前缀索引
  - 多列索引

### 6.5.1 主键索引

必须要有的索引，用于构建聚簇索引的基本条件

一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。

关键字及创建方式:

```mysql
  PRIMARY KEY (`id`)
```

### 6.5.2 普通单列索引

普通索引是最基本的索引类型，唯一的任务是加快对数据的访问速度，没有任何限制。

关键字及创建方式:

```mysql
CREATE INDEX index_name ON TABLE(column_name);
ALTER TABLE table_name ADD INDEX index_name(column_name);
INDEX index_name (name(length))
```

### 6.5.3 唯一索引

索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

关键字及创建方式:

```mysql
UNIQUE INDEX index_name (column_name)
CREATE UNIQUE INDEX index_name ON mytable(column_name)
ALTER TABLE table_name ADD UNIQUE indexName(column_name)

```

### 6.5.4 前缀索引

有时候需要索引很长的字符列，这会让索引变得大且慢。

通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。

换句话说，`前缀的”基数“应该接近于完整的列的”基数“`。

【注意】前缀索引只能作用在普通索引上 不能作用在唯一索引上

那就是计算完整列的选择性，并使其前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：

```mysql
mysql> select count(distinct city) / count(*) from city_demo;
+---------------------------------+
| count(distinct city) / count(*) |
+---------------------------------+
|                          0.4283 |
+---------------------------------+
1 row in set (0.05 sec)

```

可以在一个查询中针对不同前缀长度的选择性进行计算，这对于大表非常有用，下面给出如何在同一个查询中计算不同前缀长度的选择性：

```mysql
mysql> select count(distinct left(city,3))/count(*) as sel3,
    -> count(distinct left(city,4))/count(*) as sel4,
    -> count(distinct left(city,5))/count(*) as sel5, 
    -> count(distinct left(city,6))/count(*) as sel6 
    -> from city_demo;
+--------+--------+--------+--------+
| sel3   | sel4   | sel5   | sel6   |
+--------+--------+--------+--------+
| 0.3367 | 0.4075 | 0.4208 | 0.4267 |
+--------+--------+--------+--------+
1 row in set (0.01 sec)
```

可以看见当索引前缀为6时的基数是0.4267，已经接近完整列选择性0.4283。

在上面的示例中，已经找到了合适的前缀长度，下面创建前缀索引：

```mysql
mysql> alter table city_demo add key (city(6));
Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0
```



前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其`缺点`：

- mysql无法使用其前缀索引做ORDER BY和GROUP BY
- 无法使用前缀索引做覆盖扫描。



### 6.5.5 多列索引

指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。

关键字及创建方式:

```mysql
ALTER TABLE table ADD INDEX name_city_age (name,city,age);
```

联合索引在内部的结构图如下图所示:

![](http://mysql317.oss-cn-beijing.aliyuncs.com/unionindex.png)

对于联合索引（a,b），where a =xxx and b =xxx，和where a=xxx 可以使用此联合索引，但是对于where b = xxx不能使用，因为b列数据在此联合索引上不是有序的。具体的索引是否生效会在以后章节介绍。



## 6.6 覆盖索引

### 6.6.1 定义

SQL只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据。

这样可以减少大量的IO操作,无需进行回表操作。

### 6.6.2 判断标准

使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为`using index`,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询

### 6.6.3 优点

覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据有以下一些优点
1、索引项通常比记录要小，所以MySQL访问更少的数据
2、索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O
3、大多数据引擎能更好的缓存索引，比如MyISAM只缓存索引
4、覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了



## 6.7 索引管理

我们可以通过`SHOW INDEX FROM table`查看表的索引情况

![](http://mysql317.oss-cn-beijing.aliyuncs.com/showindex.png)



具体每个字段的含义如下:

下面我们一起了解下返回的这张表的含义：

1. Table: 表名
2. Non_unique: 如果索引不能包括重复值则为0，如果可以则为1。也就是平时所说的唯一索引。
3. Key_name 索引名称，如果名字相同则表明是同一个索引，而并不是重复，比如上图中的而三条数据，其实是一个联合索引。
4. Seq_in_index 索引中的列序列号，从1开始。上图中的二、三数据，Seq_in_index一个是1一个是2，就是表明在联合索引中的顺序，我们就能推断出联合索引中索引的前后顺序。
5. Column_name 索引的列名。
6. Collation指的是列以什么方式存储在索引中，可是A或NULL,Btree总是A,即排序的。
7. Cardinality 是基数的意思，表示索引中唯一值的数目的估计值。我们知道某个字段的重复值越少越适合建索引，所以我们一般都是根据Cardinality来判断索引是否具有高选择性，如果这个值非常小，那就需要重新评估这个字段是否适合建立索引。
8. Sub_part 前置索引的意思，如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。
9. Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。压缩一般包括压缩传输协议、压缩列解决方案和压缩表解决方案。
10. .Null 如果列含有NULL，则含有YES。
11. .Index_type表示索引类型，Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。
12. .Comment Index_comment 注释的意思。

### 6.7.1 什么是Cardinality

不是所有的查询条件出现的列都需要添加索引。对于什么时候添加B+树索引。一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，他们可取值范围很小，称为低选择性。如

```mysql
SELECT * FROM student WHERE sex='M'
```



按性别进行查询时，可取值一般只有M、F。

因此SQL语句得到的结果可能是该表50%的数据(加入男女比例1:1)这时添加B+树索引是完全没有必要的。

相反，如果某个字段的取值范围很广，几乎没有重复，属于高选择性。则此时使用B+树的索引是最合适的。

例如对于姓名字段，基本上在一个应用中不允许重名的出现

### 6.7.2 查看高选择性

怎样查看索引是否有高选择性？通过SHOW INDEX结果中的列Cardinality来观察。非常关键，表示所以中不重复记录的预估值，需要注意的是Cardinality是一个预估值，而不是一个准确值基本上用户也不可能得到一个准确的值

在实际应用中，`Cardinality/n_row_in_table应尽可能的接近1`，如果非常小,那用户需要考虑是否还有必要创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对于字段添加B+树索引是非常有必要的。如

```mysql
SELECT * FROM member WHERE usernick='David';
```

表member大约有500W行数据,usernick字段上有一个唯一索引。这也符号提到的高选择性

### 6.7.3 Cardinality统计

Cardinality统计时放在存储引擎层进行的

在生成环境中，索引的更新操作可能非常频繁。如果每次索引在发生操作时就对其进行Cardinality统计，那么将会对数据库带来很大的负担。另外需要考虑的是，如果一张表的数据非常大，如一张表有50G的数据，那么统计一次Cardinality信息所需要的时间可能非常长。这样的环境下，是不能接受的。因此，数据库对于Cardinality信息的统计都是通过采样的方法完成

在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：insert和update。InnoDB存储引擎内部对更新Cardinality信息的策略为:

- 表中1/16的数据已发生了改变
- stat_modified_counter>2000 000 000

接着考虑InnoDB存储引擎内部是怎样进行Cardinality信息统计和更新操作呢？同样是通过采样的方法。默认的InnoDB存储引擎对8个叶子节点Leaf Page进行采用。采用过程如下

1. 取得B+树索引中叶子节点的数量，记为A
2. 随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，即为P1，P2....P8
3. 通过采样信息给出Cardinality的预估值:Cardinality=(P1+P2+...+P8)*A/8

根据上述的说明可以发现，在InnoDB存储引擎中，Cardinality值通过对8个叶子节点预估而得的。而`不是一个实际精确的值`。再者，每次对Cardinality值的统计，都是通过随机取8个叶子节点得到的，这同时有暗示了另外一个Cardinality现象，即每次得到的Cardinality值可能不同的;

当然，有一种情况可以使得用户每次观察到的索引Cardinality值是一样的。那就是表足够小，表的叶子节点树小于或者等于8个