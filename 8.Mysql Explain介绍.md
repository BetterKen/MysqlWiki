

# 8 Mysql Explain介绍

## 8.1 Explain各列意义

EXPLAIN 命令的输出内容大致如下:

```mysql
mysql> explain select *  from t_scrm_user_info where bigdata_user_id > 'A1001036' and bigdata_user_id < 'A2100000'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t_scrm_user_info
   partitions: NULL
         type: range
possible_keys: UQ_CUSTOMER_ID
          key: UQ_CUSTOMER_ID
      key_len: 130
          ref: NULL
         rows: 168902
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```



|列名称|含义|
|:----:|:----:|
|id| SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.|
|select_type| SELECT 查询的类型.|
|table| 查询的是哪个表|
|partitions| 匹配的分区|
|type| join 类型|
|possible_keys| 此次查询中可能选用的索引|
|key| 此次查询中确切使用到的索引.|
|ref| 哪个字段或常数与 key 一起被使用|
|rows| 显示此查询一共扫描了多少行. 这个是一个估计值.|
|filtered| 表示此查询条件所过滤的数据的百分比|
|extra| 额外的信息|

## 8.2 id

表示select标识符，同时表明执行顺序，也就是说id是一个查询的序列号，查询序号即为sql语句执行的顺序。

1. 当id值相同时，按从上到下的顺序执行
2. 当id全部不同时，按id从大到小执行
3. 当id部分不同时，先执行id大的，id相同的，按从上到下的顺序执行



## 8.3 select_type

1. SIMPLE 简单的select查询，查询中不包含子查询或者UNION
2. PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY
3. SUBQUERY 在SELECT或WHERE列表中包含了子查询
4. DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中
5. UNION 若第二个SELECT出现在UNION之后，则被标记为UNION：若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED
6. UNION RESULT 从UNION表获取结果的SELECT

```mysql
mysql> explain select * from t_scrm_user_info where  id = 1\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t_scrm_user_info
   partitions: NULL
         type: const
possible_keys: PRIMARY,IX_ID_CREATE_TIME
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
==================================================================================
mysql> explain select * from (select * from t_scrm_pet_info limit 20) t where  t.id = (select id from t_scrm_map limit 1)\G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: <derived2>
   partitions: NULL
         type: ref
possible_keys: <auto_key0>
          key: <auto_key0>
      key_len: 4
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 3
  select_type: SUBQUERY
        table: t_scrm_map
   partitions: NULL
         type: index
possible_keys: NULL
          key: IX_CREATE_TIME
      key_len: 5
          ref: NULL
         rows: 11271619
     filtered: 100.00
        Extra: Using index
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: t_scrm_pet_info
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4578062
     filtered: 100.00
        Extra: NULL
3 rows in set, 1 warning (0.00 sec)

ERROR: 
No query specified

==================================================================================

mysql> explain select * from t_scrm_map where id =10 union select * from t_scrm_map where id = 20\G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t_scrm_map
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 2
  select_type: UNION
        table: t_scrm_map
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: NULL
  select_type: UNION RESULT
        table: <union1,2>
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: Using temporary
3 rows in set, 1 warning (0.00 sec)

```





## 8.4 table

这一列表示 explain 的一行正在访问哪个表。

当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。当有 union 时，UNION RESULT 的 table 列的值为 <union1,2>，1和2表示参与 union 的 select 行id。

## 8.5 partitions 

使用的哪些分区（对于非分区表值为null）

## 8.6 type

type所显示的是查询使用了哪种类型，type包含的类型包括如下图所示的几种：

从最好到最差依次是：

```
system > const > eq_ref > ref > range > index > all
```



一般来说，得保证查询至少达到range级别，最好能达到ref。

- `const, system`：mysql能对查询的某部分进行优化并将其转化成一个常量。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。

```mysql
mysql> explain select * from t_scrm_user_info where bigdata_user_id = 'B13470427'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t_scrm_user_info
   partitions: NULL
         type: const
possible_keys: UQ_CUSTOMER_ID
          key: UQ_CUSTOMER_ID
      key_len: 130
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

```

- `eq_ref`：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的`联接类型`了，简单的 select 查询不会出现这种 type。

```mysql
mysql> explain select * from t_scrm_user_info u left join t_scrm_map m on u.bigdata_user_id = m.bigdata_id where u.bigdata_user_id = 'B13470427'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: u
   partitions: NULL
         type: const
possible_keys: UQ_CUSTOMER_ID
          key: UQ_CUSTOMER_ID
      key_len: 130
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: m
   partitions: NULL
         type: ref
possible_keys: UQ_ID
          key: UQ_ID
      key_len: 258
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where
2 rows in set, 1 warning (0.00 sec)

```

- ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。

```mysql
mysql> explain select * from t_scrm_map where target_id = '11255964'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t_scrm_map
   partitions: NULL
         type: ref
possible_keys: IX_TRAGET_ID
          key: IX_TRAGET_ID
      key_len: 130
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

